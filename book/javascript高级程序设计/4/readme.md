# 第4章 变量、作用域和内存问题

- 理解基本类型和引用类型的值
- 理解执行环境
- 理解垃圾收集

## 基本类型和引用类型的值

ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。

- 基本类型值--简单的数据段

  - Undefined、Null、Boolean、Number 和 String。这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值
- 引用类型值--那些可能由多个值构成的对象。
  - 引用类型的值是保存在内存中的对象，JavaScript不允许直接访问内存中的位置，即不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 为此，引用类型的值是按引用访问的
- 动态的属性
  
定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值

  - 对于引用类型的值，我们可以为其添加属性和方法，改变和删除其属性和方法
  - 不能给基本类型的值添加属性
  
- 复制变量值
  - 基本类型的值：如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制 到为新变量分配的位置上，这两个变量可以参与任 何操作而不会相互影响
  - 引用类型的值：将存储在变量对象中的值复制一份放到为新变量分配的空间中，不同的是，这个值的副本实际上是一个指针，指针指向存储在堆中的一个对象，复制操作结束后，两个变量引用同一个对象，改变其中一个变量，就会影响另 一个变量
- 传递参数
  ECMAScript 中所有函数的参数都是按值传递的，把函数外部的值复制给函数内部的参数，和把值从一个变量复制到另一个变量一样
  - 访问变量有按值和按引用两种方式，而参数只能按值传递
- 检测类型
  - 检测基本数据类型-typeof
  - 检测引用类型的值-instanceof 操作符
    - 变量是给定引用类型的实例，返回true
    - 所有引用类型的值都是 Object 的实例
    - 使用 instanceof 操作符检测基本类型的值，返回 false，因为基本类型不是对象。
  - typeof 操作符检测函数时，返回"function"
  
## 执行环境（execution context）及作用域

  > 每个执行环境都有一个与之关联的变量对象

  > 环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁

  > 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境

  > 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）_保证对执行环境有权访问的所有变量和函数的有序访问:作用域链的前端-当前执行的代码所 在环境的变量对象.如果这个环境是函数，则将其活动对象（activation object）作为变量对象

  > 全局执行环境的变量对象始终都是作用域链中的最后一个对象

  > 标识符解析-沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止

  > 每个环境都 可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个 执行环境。
- 延长作用域链
  - try-catch 语句的 catch 块
  - with 语句
- 没有块级作用域
  > if 语句中的变量声明会将变量添加到当前的执行环境

  > for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在 于循环外部的执行环境中

  - 声明变量
    > 初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境
  - 查询标识符
    > 从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符

    > 使用 ```window.name``` 能访问到全局变量

## 垃圾收集
  
  JavaScript 具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存
  > 标识无用变量的策略(具体到浏览器中的实现):两个策略

- 标记清除-最常用的垃圾收集方式
- 引用计数-不太常见的垃圾收集策略.释放引用次数为零的值所占用的内存
- 性能问题
  - 垃圾收集器是周期性运行的.变量分配的内存数量很大，回收工作量越大
- 管理内存
  - 优化内存占用的最佳方式：为执行中的代码只保存必要的数据
  - 一旦数据不再有用，最好通过将其值设置为 null 来释放其引用———解除引用（dereferencing）
  - 局部变量会在 它们离开执行环境时自动被解除引用
  - 解除一个值的引用并不意味着自动回收该值所占用的内存，真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收

## 小结

基本类型值和引用类型值具 有以下特点：

- 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
- 引用类型的值是对象，保存在堆内存中；
- 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同 一个对象；
- 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。

所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量：

- 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
- 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全 局环境；
- 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
- 变量的执行环境有助于确定应该何时释放内存。

JS具有自动垃圾收集机制，开发人员不必关心内存分配和回收问题：

- “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存
- 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用