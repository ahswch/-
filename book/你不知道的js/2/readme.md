# Chapter2 词法作用域

- 作用域的两种主要工作模型
  - 词法作用域：定义在词法阶段的作用域
  - 动态作用域

## 词法阶段

> 大部分语言编译器的第一个工作阶段叫作词法化，也叫单词化。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义
> 没有任何函数可以部分地同时出现在两个父级函数中

- 查找
  - 从最内部的作用域逐级向上查找，在找到第一个匹配的标识符时停止
  - 在多层嵌套作用域中可以定义同名的标识符 —— 遮蔽效应（内遮外）
  - 全局变量会自动成为全局对象（浏览器中的 window 对象），可不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问（如`window.a`）
  - 词法作用域只由函数被声明时所处的位置决定
  - 词法作用域只会查找一级标识符（P16 reject）

## 欺骗词法

> 如果词法作用域完全由写代码期间函数声明的位置来定义，怎样才能在运行时来“修改”（欺骗）词法作用域呢？JS 有 2 中机制来实现这个目的。
> 欺骗词法作用域会导致性能下降。程序中动态生成代带来的好处无法抵消性能上的损耗

- eval（机制 1， 不推荐使用）

  - 接受一个字符串为参数。将其中的内容视为好像在书写时就存在于程序中这个位置的代码。如下例子

  ```javascript
  function foo(str, a) {
    eval(str); // 欺骗
    console.log(a, b);
  }

  var b = 2;
  foo('var b = 3;', 1); // 1, 3
  // 在foo(...)内部同时找到a和b，永远无法找到外部的b
  ```

  - 严格模式的程序中，eval(...)在运行时有其自己的词法作用域，其中的声明无法修改所在的作用域
  - 类似的 `setTimeout()`和`setInterval()`接受的第一个参数可以是字符串，字符串的内容可被解释为一段动态生成的代码。不提倡使用

- with（机制 2， 不推荐使用）
  - 通常被当作重复引用一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身
  - with 可将一个没用或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域的词法标识符。但这个块内部正常的 var 声明不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中
  - 严格模式下 with 被禁止

> eval 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域

- 性能

> 上述两种机制会在运行时修改或创建新的作用域来欺骗其他在书写时定义的词法作用域

- JS 引擎在编译阶段进行优化时，有些优化依赖于能够根据代码的词法来进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符

## 小结

- 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找
- 两个欺骗词法作用域的机制（不推荐使用）
