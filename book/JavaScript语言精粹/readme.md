# JavaScript语言精粹

## Chapter 1 精华

定义新方法

```javascript
Function.prototype.method = function (name, func) {
    this.prototype[name] = func;
    return this;
};
```

## Chapter 2 语法

- 空白（whitespace）
  - var 后的空格不能省略
  - 使用// 作代码注释
- 标识符（Names）：由一个字母开头，后选择性加一个或多个字母、数字或下划线（不能使用保留字）
  - 可用于语句、变量、参数、属性名、运算符和标记
- 数字（内部表示为64位浮点数）
  - 数字字面量有指数部分 值为e之前的数字与10的e之后数字次方相乘
  - 负数用前置运算符 - 加数字构成
  - NaN是一个数值，表示一个不能产生正常结果的运算结果。NaN不等于任何值包括自己。可以使用`isNaN(number)`检测NaN
  - Infinity表示所有大于`1.79769313486231570e+308`的值
  - 数字拥有方法 包含于js对象Math中
- 字符串：被包在一对单引号或双引号中，可包含0个或多个字符 `\`是转义字符
  - Unicode是一个16位的字符集 所以JavaScript中的所有字符都是16位的
  - JavaScript没有字符类型，要表示一个字符，只需创建仅包含一个字符的字符串即可
  - 转义字符用来把那些正常情况下不被允许的字符插入到字符串中，如反斜线、引号和控制字符
  - `\u`约定用来指定数字字符编码 `"A" === "\u0041"`
  - 字符串有一个length属性
  - 字符串是不可变的。一旦被创建，永远无法改变它。可以通过`+`运算符连接其他字符串来创建新字符串。两个包含着完全相同的字符且字符顺序也相同的字符串被认为是相同的字符串 `'c' + 'a' + 't' === 'cat' // true`
  - 字符串方法（具体见第八章）
- 语句（statement）
  - 一个编译单元包含一组可执行的语句。在Web浏览器中，每个`<script>`标签提供一个被编译且立即执行的编译单元，无链接器，js把它们一起抛到一个公共的全局名字空间中
  - var语句被用在函数内部时，它定义的是这个函数的私有变量
  - switch、while、for和do语句允许有一个可选的前置标签（label），它配合break语句来使用
  - 语句通常按照从上到下的顺序被执行。Javascript可以通过条件语句（if和switc）、循环语句（while、for和do）、强制跳转语句（break、return和throw）和函数调用来改变执行序列
  - 代码块是包在一对花括号中的一组语句，js中的代码块不会创建新的作用域，因此变量应该被定义在函数的头部，而不是在代码块中
  - if语句根据表达式的值改变程序流程。表达式的值为真时执行跟在其后的代码块，否则，执行可选的else分支
    - 下列值被当作假（false）
      - false
      - null
      - undefined
      - 空字符串`' '`
      - 数字0
      - 数字NaN
    - 其他所有的值都被当做真
  - switch语句
  - while语句
  - for语句
    - 常见形式：由3个可选从句控制（初始化从句、条件从句和增量从句）
    - for in语句 通常需要使用`object。hasOwnProperty(variable)`来确定这个属性名是该对象的成员还是来自于原型链
  - do语句
  - try语句执行一个代码块，并捕获该代码抛出的任何异常。catch从句定义一个新的变量variable来接受抛出的异常对象
  - throw语句抛出一个异常。如果throw语句在一个try代码块中，控制流就会跳转到catch从句中
    - 语句中的表达市场通常是一个对象字面量，它包含一个name属性和一个message属性。异常捕获器可以使用这些信息去决定该做什么
  - return语句会导致从函数中提前返回。它可以指定要被返回的值。如果没有指定返回表达式，返回值是undefined js不允许在return关键字和表达式之间换行
  - break语句会使程序退出一个循环语句或switch语句。他可以指定一个可选的标签，那退出的就是带标签的语句 js不允许在break关键字和标签之间换行
  - 一个expression语句可以给一个或多个变量或成员赋值，或者调用一个方法，或者从对象中删除一个属性。
- 表达式（expression）
  - 最简单的表达式是字面量值（比如字符串或数字）、变量、内置的值（false、true、null、undefined、NaN和Infinity）、以new开头的调用表达式、以delete开头的属性提取表达式、包在圆括号中的表达式、以一个前置运算符作为前导的表达式，或者表达式后面跟着：
    - 一个中置运算符与另一个表达式
    - 三元运算符 ? 后面跟着另一个表达式，然后接一个 : ，再然后接第三个表达式
    - 一个函数调用
    - 一个属性提取表达式
  - 运算符优先级

  |运算符|说明|
  |---|---|
  |. [] ( ) | 提取是属性与调用函数|
  |delete new typeof + - !|一元运算符|
  |* / %|乘法、除法、求余|
  |+ -|加法/连接、减法|
  |>= <= > <|不等式运算符|
  |=== !==|等式运算符|
  |&&|逻辑与|
  |\|\||逻辑或|
  |? :|三元|

  - typeof运算符产生的值有'number'、'string'、'undefined'、'boolean'、'function'和'object'（es5 新增'symbol'）
  - `+`运算符可以进行加法运算或字符串连接
  - `/`运算符可能会产生一个非整数结果，即使两个运算数都是整数
  - 如果第一个运算数的值为假，那么运算符`&&`产生它的第一个运算数的值，否则产生第二个运算数的值
  - 如果第一个运算数的值为真，那么运算符`||`产生它的第一个运算数的值，否则产生第二个运算数的值
  - 函数调用引发函数执行
- 字面量（Literals）
  - 对象字面量是一种可以方便地按制定规格创建新对象的表示法。属性名可以是标识符或字符串。这些名字被当做字面量名而不是变量名来对待，所以对象的属性名在编译时才能知道。属性的值就是表达式
  - 数组字面量是一种可以方便地按指定规格创建新数组的表示法。
- 函数
  - 函数字面量定义了函数值。它有一个可选的名字，用于递归的调用自己。也可以指定一个参数列表，这些参数就像变量一样，在调用时由传递的的实际参数（argument）初始化。
  - 函数主体包括变量定义和语句

## Chapter 3 对象

js的简单数据类型包括数字、字符串、布尔值、null值和undefined值。其他所有的值都是对象

- js中的对象是可变的键控集合（keyed collections）
- 对象是属性的容器，其中每个属性都拥有名字和值。属性的名字可以是包含空字符串在内的任意字符串。属性值可以是除undefined值之外的任何值
- js里的对象是无类型（class-free）的。它对新属性的名字和属性的值没有限制。对象适合用于汇集和管理数据。对象可以包含其他对象，所以它们可以吃容易地表示成树状或图形结构
- js包含一种原型链的特性，允许对象继承另一个对象的属性。正确地使用它能减少对象初始化消耗的时间和内存

### 对象字面量（Object Literals）

- 对象字面量提供了一种非常方便的创建对象值的表示法。一个对象字面量就是包围在一对花括号中的零个或多个“名/值”对。对象字面量可以出现在任何允许表达式出现的地方
- 属性名可以是包含空字符串在内的任何字符串。在对象字面量中，如果属性名是一个合法的js标识符且不是保留字，则并不强制要求用引号括住属性名。所以用引号括住`"first-name"`是必需的，但是否括住`first_name`则是可选的。逗号用来分隔多个“名/值”对
- 属性的值可以从包括另一个对象字面量在内的任意表达式中获得。对象是可嵌套的

### 检索（Retrieval）

要检索对象里包含的值，可以采用在[]后缀中括住一个字符串表达式的方式。如果字符串表达式是一个字符串字面量，而且它是一个合法的JavaScript标识符且不是保留字，那就可以用`.`代替，优先使用`.`

- 检索一个不存在的成员属性的值，将返回undefined
- `||`运算符可以用来填充默认值
- 尝试从undefined的成员属性中取值会导致TypeError异常。可以通过`&&`运算符来避免错误

### 更新

- 对象里的值可以通过赋值语句来更新
- 如果对象之前没有拥有那个属性名，那么该属性就会被扩充到对象中

### 引用（Reference）

- 对象通过引用来传值。它们永远不会被复制

### 原型（Prototype）

- 每个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过字面量创建的对象都连接到`Object.prototype`，它是Javascript中的标配对象
- 当你创建一个新对象时，你可以选择某个对象作为它的原型。Javascript提供的实现机制杂乱复杂，我们可以简化，给`Object`增加一个create方法。这个方法创建一个使用原对象作为其原型的新对象
- 原型连接在更新时是不起作用的。当我们对某个对象做出改变时，不会触及该对象的原型
- 原型连接只有在检索值的时候才会被用到。如果我们尝试去获取对象的某个属性值，但该对象没有此属性名，那么Javascript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么会沿着原型链继续向上级原型寻找，直到该过程最后到达终点`Object.prototype`，如果想要的属性完全不存在于原型链中，结果就是undefined值。这个过程称为委托
- 原型关系是一种动态关系。如果我们添加一个新属性到原型中，该属性会立即对所有基于该原型创建的对象可见

### 反射（Reflection）

- `typeof`用于确定属性的类型
- 原型链中的任何属性都会产生值
- 去除原型链中不需要的属性
  - 程序做检查并丢弃值为函数的属性
  - 使用`hasOwnProperty`方法，如果对象拥有独有的属性，它将会返回true，该方法不会检查原型链

### 枚举（Enumeration）

- `for in`语句可以用来遍历一个对象中的所有属性名。该枚举过程将会列出所有的属性——包括函数和你不关心的原型中的属性——所以有必要过滤掉那些不需要的值。最常用`hasOwnProperty`方法进行过滤，以及使用`typeof`来排除函数
- 属性名出现的顺序是不确定的，如果想要属性以特定顺序出现，最好不要使用该语句
- 通过使用`for`而不是`for in`，可以得到我们想要的属性，不用担心可能取到原型链中的属性，且按正确的顺序获取了它们的值

### 删除

- `delete`运算符可以用来删除对象的属性。不会触及原型链中的任何对象
- 删除对象的属性可能会让来自原型链中的同名属性透现出来

### 减少全局变量污染（Global Abatement）

- Javascript可以随意定义全局变量，削弱了程序的灵活性，应避免使用
- 最小化使用全局变量的方法之一是为你的应用值创建一个唯一的全局变量`var MYAPP = {}`
- 该变量作为容器，把全局性的资源都存入其中，这样你的程序与其他程序、组件或类库之间发生冲突的可能性就会降低，程序更易阅读（`MYAPP.stooge`指向的是顶层结构），后面会使用闭包来隐藏信息，它是一种有效减少全局污染的方法

## Chapter 4 函数

函数包含一组语句，它们是Javascript的基础模块单元，用于代码复用、信息隐藏和组合调用。函数用于指定对象的行为。一般来说，所谓编程，就是将一组需求分解成一组函数与数据结构的技能

### 函数对象

- Javascript中的函数就是对象。对象是“名/值”对的集合并拥有一个连到原型对象的隐藏连接。对象字面量产生的对象连接到`Object.prototype`。函数对象连接到`Function.prototype`（该原型对象本身连接到`Object.prototype`）。每个函数在创建时也随配有一个`prototype`属性。它的值是一个拥有`constructor`属性且值为该函数的对象。这和隐藏连接到`Function.prototype`完全不同。下章详细讲解
- 函数是对象，所以它们可以像任何其他值一样被使用。函数可以保存在变量、对象和数组中，可以被当做参数传递给其他函数，也可以再返回函数。而且，因为函数是对象，所以函数可以拥有方法
- 函数的特点吗是可以被调用

### 函数字面量（Function Literal）

- 函数对象通过函数字面量来创建

  ``` javascript
  var add = function = function (a, b) {
    retutn a + b;
  }
  ```

  - 保留字`function`
  - 函数名，可以被省略（匿名函数anonymous）
  - 包围在圆括号里的一组参数，多个用逗号隔开，参数名将被定义为函数中的变量。不像普通的变量那样被初始化undefined，而是在函数被调用时初始化为实际提供的参数值
  - 包围在花括号中的一组语句。这些语句时函数的主题，在函数被调用时执行
- 函数字面量可以出现在任何允许表达式出现的地方。函数也可以被定义在其他函数中。一个内部函数除了可以访问自己的参数和变量，还可以自由访问把它嵌套在其中的父函数的参数与变量。
  - 通过函数字面量创建的函数对象包含一个连到外部上下文的连接。这被称为闭包（closure）

### 调用（Invocation）

- 调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数
- 除了声明时定义的形式参数，每个函数还接受两个附加的参数：this和arguments。参数this在面向对象编程过程中非常重要，他的值取决于调用的模式，在JavaScript中一共有4种调用模式。（这些模式在如何初始化关键参数this上存在差异
  - 方法调用模式
  - 函数调用模式
  - 构造器调用模式
  - apply调用模式
- 调用运算符是跟在任何产生一个函数值的表达式之后的一对圆括号
  - 圆括号内可包含零个或多个逗号隔开的表达式
  - 每个表达式产生一个参数值
  - 每个参数值被赋予函数声明时定义的形式参数名
  - 当实际参数（arguments）的个数与形式参数（parameters）的个数不匹配时，不会导致运行时错误。如果实际参数值过多了。超出的参数值会被忽略。如果实际参数值过少，缺失的值会被替换为undefined
  - 对参数值不会进行类型检查：任何类型的值都可以被传递给任何参数

### 方法调用模式（The Method Invocation Pattern）

- 当一个函数被保存为对象的一个属性时。我们称它为一个方法。当一个放方法被调用时，this被绑定到该对象。如果调用表达式包含一个提取属性的动作（即包含一个`.`点表达式或`[subscript]`下标表达式），那么它就是被当做一个方法来调用
- 方法可以使用this访问自己所属的对象，所以它能从对象中取值或对对象进行修改
- this到对象的绑定发生在调用的时候。这个“超级”延迟绑定（very late binding）使得函数可以对this高度复用
- 通过this可取得它们所属对象的上下文的方法称为公共方法（public method）

### 函数调用模式（The Function Invocation Pattern）

- 当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的

  ``` javascript
  var sum = add(3, 4); // sum的值为7
  ```

- 以此模式调用函数时，this被绑定到全局对象
  - 这是语言设计上的一个错误。倘若语言设计正确，那么当内部函数被调用时，this应该仍然绑定到外部函数的this变量。这个设计错误的后果就是方法不能利用内部函数来帮助它工作，因为内部函数的this被绑定了错误的值，所以不能共享该方法对对象的访问权
  - 上述问题，解决方案：如果该方法定义一个变量并给它赋值为this，那么内部函数就可以通过那个变量访问到this，按照约定，我们把那个变量命名为that

### 构造器模式调用模式（The Constructor Invocation Pattern）

> JavaScript是一门基于原型继承的语言。这意味着对象可以直接从其他对象继承属性。该语言是无类型的。当今编程语言主流风格都是基于类的语言。JavaScript提供了一套基于类的语言类似的对象构建语法

- 在一个函数前面带上`new`来调用，将会创建一个连接到该函数的`prototype`成员的新对象，同时this会被绑定到那个新对象上
- `new`前缀也会改变`return`语句的行为
- 一个函数，如果创建的目的就是希望结合`new`前缀来调用，那它就会被称为构造器函数。按照约定看，它们保存在以大写格式（首字母大写）命名的变量里

### Apply调用模式（The Apply Invocation Pattern）

> 因为JavaScript是一门函数式的面向对象编程语言，所以函数可以拥有方法

- `apply`方法让我们构建一个参数数组传递给调用函数。它也允许我们选择this的值
- `apply`方法接受两个参数，第一个是要绑定给this的值，第2个就是一个参数数组

### 参数（Arguments）

- 当函数被调用时，会得到一个“免费”配送的参数，那就是`arguments`数组。函数可以通过此参数访问它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形式参数的多余参数。这使得编写一个无须指定参数个数的函数称为可能
- 不是特别有用的模式，在第六章中，会看到如何给数组添加一个相似的方法来达到同样的效果
- 因为语言的一个设计错误，`arguments`并不是一个真正的数组。它只是一个“类似数组（array-like）”的对象。`arguments`拥有一个length属性，但它没有任何数组的方法。本章结尾会看到该设计所导致的后果

### 返回

- 当一个函数被调用时，它从第一个语句开始执行，并在遇到关闭函数体的`}`时结束。然后把控制权交还给调用该函数的程序
- `return`语句可以用来使函数提前返回。当`return`被执行时，函数立即返回而不会执行余下的语句
- 一个函数总会返回一个值。如果没有指定返回值，则返回`undefined`
- 如果函数在调用时在前面加上了new前缀，且返回值不是一个对象，则返回this（该新对象）

### 异常（Exceptions）

- JavaScript提供了一套异常处理机制。异常是干扰程序正常流程的不寻常（但并非完全是出乎意料的）的事故。当发现这样的事故时，你的程序应该抛出一个异常：

``` javascript
var add = function (a, b) {
  if (typeof a !== 'number' || typeof b !== 'number') {
    throw {
      name: 'TypeError',
      message: 'add needs numbers'
    };
  }
  return a + b;
}
```

- throw语句中断函数的执行。它应该抛出一个`exception`对象，该对象包含一个用来识别异常类型的name属性和一个描述性的message属性。你也可以添加其他的属性
- 该exception对象将被传递到一个try语句的catch从句

``` javascript
// 构造一个try_it函数，以不正确的方式调用之前的add函数
var try_it = function () {
  try {
    add("seven");
  } catch (e) {
    document.writeIn(e.name + ':' + e.message);
  }
}

try_it();
```

- 如果try代码块内抛出了一个异常，控制权就就会跳转到它的catch从句
- 一个try语句只会有一个捕获所有异常的catch代码块。如果你的处理手段取决于异常的类型，那么异常处理器必须检查异常对象的name属性来确定异常的类型

### 扩充类型的功能（Augmenting Types）

- JavaScript允许给语言的基本类型扩充功能。第三章中，通过给`Object.prototype`添加方法，可以让该方法对所有对象都可用。这样的方式对函数、数组、字符串、数字、正则表达式和布尔值同样适用
  - 比如，通过给`Function.prototype`增加方法来使得该方法对所有函数可用
- JavaScript没有专门的整数类型。如果需要只提取数字中的整数部分。JavaScript本身提供的方法有些丑陋。我们可以通过给`Number.prototype`增加一个integer方法来改善它。它会根据数字的正负来判断是使用`Math.ceiling`还是`Math.floor`

``` javascript
Number.method('integer', function () {
  return Math[this < 0 ? 'ceil' : 'floor'](this)
});
document.writeIn((-10/3).integer()); // -3
```

- JavaScript缺少一个移除字符串首尾空白的方法。可以使用以下方法弥补

``` javascript
String.method('trim', function () {
  return this.replace(/^\s+|\s+$/g, '');
});
document.writeIn('"' + "  neat  ".trim() + '"');
```

- 基础类型的原型是公用结构，在类库混用时务必小心。保险做法是：只在确定没有该方法时才添加它

### 递归（Recursion）

- 递归函数是会直接或间接地调用自身的一种函数。一个递归函数调用自身去解决它的子问题
- 递归函数可以非常高效的操作树形结构，比如浏览器端的文档对象模型（DOM）。每次递归调用时处理指定的树的一小段

### 作用域（Scope）

- 编程语言中，作用域控制着变量与参数的可见性及生命周期

### 闭包（Closure）

- 作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了this和arguments）
- 内部函数拥有比它的外部函数更长的声明周期

### 回调（Callbacks）

- 函数使得对不连续事件的处理变得更容易（异步请求）

### 模块（Module）

- 可以使用函数和闭包来构造模块
- 模块是一个提供接口却隐藏状态与实现的函数或对象
- 模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可以访问到的地方
- 通过使用函数产生模块，可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。对于应用程序的封装，或者构造其他单例对象，模块模式非常有效
- 模块模式也可以用来产生安全的对象
- 模块模式通常结合单例模式使用
- JavaScript的单例就是用对象字面量表示法创建的对象，对象的属性值可以是数值或函数，并且属性值在该对象的生命周期中不会发生变化。它通常作为工具为程序或其他部分提供功能支持

### 级联（Cascade）

有一些方法没有返回值。如：一些设置或修改对象的某个状态却不返回任何值的方法就是典型的例子。如果我们让这些方法返回this而不是undefined，就可以启用级联

- 在一个级联中，我们可以在单独一条语句中依次调用同一个对象的很多方法

### 柯里化（Curry）

- 柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数

### 记忆（Memoization）

- 函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复计算，这种优化被称为记忆

## Chapter 5 继承（Inheritance）

- 代码重用的一种形式
- 如果一个新的类与一个已存在的类大部分相似，那么只需说明其不同点即可（其他语言）
- JavaScript是一门弱类型语言，不需要类型转换。它提供了一套更为丰富的代码重用模式，同时它也可以支持其他更具表现力的模式
- JavaScript中可能的继承模式有很多，本章研究几种最为直接的模式

### 伪类（Pseudoclassical）

- 所有构造器函数都约定命名成首字母大写的形式

### 对象说明符

- 在编写构造器时让他接受一个简单的对象说明符

### 原型（Prototypal）

> 一个新对象可以继承一个旧对象的属性

### 函数化(Functional)

> 私有变量和私有函数

- 应用模块模式
  - 创建一个新对象
  - 有选择地定义私有实例变量和方法
  - 给这个新对象扩充方法.这些方法拥有特权去访问参数
  - 返回那个对象

### 部件(Parts)
